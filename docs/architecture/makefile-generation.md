# Makefile Generation System

## Overview

Agentize SDK automatically generates language-aware Makefiles during project initialization. The generated Makefile provides a unified interface for building, testing, and managing the development environment across Python, C, C++, and Rust projects.

**Key capabilities**:
- Language-specific build, test, clean, and lint targets
- Environment setup via `make env` and `make env-script`
- Automatic dependency aggregation across multiple languages
- Discoverable interface via `make help`

## Template System

### Template Selection

During project initialization, Agentize detects project languages and selects appropriate Makefile templates:

| Language | Template Path | Detection Method |
|----------|---------------|------------------|
| Python | `templates/python/Makefile.template` | `setup.py`, `.py` files |
| C | `templates/c/Makefile.template` | `.c`, `.h` files |
| C++ | `templates/cxx/Makefile.template` | `.cpp`, `.hpp` files |
| Rust | `templates/rust/Makefile.template` | `Cargo.toml` |

### Template Concatenation

The `generate_enhanced_makefile()` function in `scripts/install.sh` (lines 433-546):

1. Creates Makefile header with help target
2. Aggregates dependencies from detected languages
3. Generates common targets (build, test, clean, lint)
4. Adds environment setup targets (env, env-script)
5. Appends language-specific templates
6. Sets `.DEFAULT_GOAL := help`

### Language-Specific Sections

Each language template defines:
- `build-<lang>`: Language-specific build steps
- `test-<lang>`: Language-specific test execution
- `clean-<lang>`: Language-specific cleanup
- `lint-<lang>`: Language-specific linting

The main Makefile aggregates these into unified `build`, `test`, `clean`, and `lint` targets.

## Environment Setup Targets

Agentize provides two mechanisms for environment setup: `make env` (eval-based) and `make env-script` (script generation).

### `make env` Target

**Purpose**: Output shell export statements for use with `eval` in the current shell.

**Implementation**:
```makefile
.PHONY: env
env:
	@echo 'export PROJECT_ROOT="$(CURDIR)"'
	@echo 'export PATH="$(CURDIR)/build/bin:$$PATH"'
	# Language-specific exports follow
```

**Usage**:
```bash
eval $(make env)
```

**Key features**:
- Uses `$(CURDIR)` for portable path resolution (GNU Make built-in)
- Outputs export statements only (no file creation)
- Safe for `eval` (no command injection risk)
- Dynamic: paths resolved at make execution time

**Example output** (Python project):
```bash
export PROJECT_ROOT="/Users/dev/myproject"
export PATH="/Users/dev/myproject/build/bin:$PATH"
export PYTHONPATH="/Users/dev/myproject/src:$PYTHONPATH"
```

### `make env-script` Target

**Purpose**: Generate/regenerate `setup.sh` script with current project paths.

**Implementation**:
```makefile
.PHONY: env-script
env-script:
	@echo "Generating setup.sh..."
	@echo '#!/bin/bash' > setup.sh
	@echo '# Generated by make env-script' >> setup.sh
	@echo 'PROJECT_ROOT="$(CURDIR)"' >> setup.sh
	@echo 'export PROJECT_ROOT' >> setup.sh
	@echo 'export PATH="$$PROJECT_ROOT/build/bin:$$PATH"' >> setup.sh
	# Language-specific exports follow
	@chmod +x setup.sh
	@echo "Generated setup.sh - run: source setup.sh"
```

**Usage**:
```bash
make env-script
source setup.sh
```

**Key features**:
- Creates executable `setup.sh` in project root
- Uses `$(CURDIR)` for path resolution at generation time
- Overwrites existing `setup.sh` if present
- Backward compatible with traditional `source setup.sh` pattern

## Dual Interface Philosophy

Agentize provides two environment setup interfaces to accommodate different workflows and user preferences.

### Interface Comparison

| Aspect | `source setup.sh` | `eval $(make env)` |
|--------|------------------|-------------------|
| **Interface** | Shell script sourcing | Make target evaluation |
| **File creation** | Yes (setup.sh) | No |
| **Discovery** | Requires documentation | Shown in `make help` |
| **Path resolution** | At source time | At make execution time |
| **Visual feedback** | Yes (script output) | Minimal |
| **Tool verification** | Can include checks | Exports only |
| **Best for** | Interactive setup, first-time users | Automation, CI/CD, Makefile-centric workflows |

### When to Use Each

**Use `source setup.sh` when**:
- Setting up environment for the first time
- Working interactively in a terminal
- Visual feedback and tool verification is desired
- Following traditional Unix workflow patterns

**Use `eval $(make env)` when**:
- Automating setup in scripts or CI/CD pipelines
- Working in a Makefile-centric workflow
- Preferring discoverable interfaces (`make help`)
- Regenerating environment after repo movement

**Both interfaces are equally valid** and provide the same environment configuration. Choose based on workflow preference.

## Generated Makefile Structure

The generated Makefile follows this structure:

```makefile
# 1. Header and help target
.DEFAULT_GOAL := help
.PHONY: help
help:
	@echo "Available targets:"
	@echo "  build       - Build the project"
	@echo "  test        - Run test suite"
	@echo "  clean       - Clean build artifacts"
	@echo "  lint        - Run linters"
	@echo "  env         - Print environment exports (use: eval \$(make env))"
	@echo "  env-script  - Generate setup.sh script"

# 2. Common targets (aggregated from languages)
.PHONY: build test clean lint
build: <language-specific-build-targets>
test: <language-specific-test-targets>
clean: <language-specific-clean-targets>
lint: <language-specific-lint-targets>

# 3. Environment setup targets
.PHONY: env env-script
env:
	# Output export statements

env-script:
	# Generate setup.sh

# 4. Language-specific targets (from templates)
# Python targets (if HAS_PYTHON=true)
.PHONY: build-python test-python clean-python lint-python

# C++ targets (if HAS_CPP=true)
.PHONY: build-cxx test-cxx clean-cxx lint-cxx

# Rust targets (if HAS_RUST=true)
.PHONY: build-rust test-rust clean-rust lint-rust
```

## Language-Specific Environment Variables

### Python Projects

**Environment variables**:
- `PYTHONPATH`: Adds `src/` directory to Python module search path

**Export in `make env`**:
```makefile
@echo 'export PYTHONPATH="$(CURDIR)/src:$$PYTHONPATH"'
```

**Export in `make env-script`**:
```makefile
@echo 'export PYTHONPATH="$$PROJECT_ROOT/src:$$PYTHONPATH"' >> setup.sh
```

### Rust Projects

**Environment variables**:
- `CARGO_TARGET_DIR`: Sets Rust build output directory

**Export in `make env`**:
```makefile
@echo 'export CARGO_TARGET_DIR="$(CURDIR)/target"'
```

**Export in `make env-script`**:
```makefile
@echo 'export CARGO_TARGET_DIR="$$PROJECT_ROOT/target"' >> setup.sh
```

### C/C++ Projects

**Environment variables**:
- `PATH`: Adds `build/bin` to system PATH

**Export in `make env`**:
```makefile
@echo 'export PATH="$(CURDIR)/build/bin:$$PATH"'
```

**Export in `make env-script`**:
```makefile
@echo 'export PATH="$$PROJECT_ROOT/build/bin:$$PATH"' >> setup.sh
```

### Multi-Language Projects

For projects with multiple languages, environment variables are aggregated. Example (Python + C++):

```bash
export PROJECT_ROOT="/Users/dev/myproject"
export PATH="/Users/dev/myproject/build/bin:$PATH"
export PYTHONPATH="/Users/dev/myproject/src:$PYTHONPATH"
```

## Implementation Details

### Core Function: `generate_enhanced_makefile()`

**Location**: `scripts/install.sh` lines 433-546

**Responsibilities**:
1. Language detection (sets `HAS_PYTHON`, `HAS_C`, `HAS_CPP`, `HAS_RUST` flags)
2. Dependency aggregation into `build_deps`, `test_deps`, `clean_deps`, `lint_deps`
3. Makefile header generation with help target
4. Environment setup targets injection
5. Language-specific template concatenation
6. `.DEFAULT_GOAL` setting

**Key implementation pattern**:
```bash
# Heredoc for injecting Makefile content
cat >> "$MASTER_PROJ/Makefile" << 'MARKER'
.PHONY: env
env:
	@echo 'export PROJECT_ROOT="$(CURDIR)"'
MARKER

# Conditional language-specific additions
if $HAS_PYTHON; then
    cat >> "$MASTER_PROJ/Makefile" << 'PYTHON_ENV'
	@echo 'export PYTHONPATH="$(CURDIR)/src:$$PYTHONPATH"'
PYTHON_ENV
fi
```

### Template Files

**Locations**:
- `templates/python/Makefile.template`: Python-specific targets
- `templates/c/Makefile.template`: C-specific targets
- `templates/cxx/Makefile.template`: C++-specific targets
- `templates/rust/Makefile.template`: Rust-specific targets

**Template concatenation**:
```bash
if $HAS_PYTHON; then
    if [ -f "$AGENTIZE_ROOT/templates/python/Makefile.template" ]; then
        cat "$AGENTIZE_ROOT/templates/python/Makefile.template" >> "$MASTER_PROJ/Makefile"
    fi
fi
```

### Reference Implementation

The `claude/templates/project-setup.sh.template` file serves as the authoritative reference for environment variables. The `make env` and `make env-script` targets replicate this functionality using Makefile constructs.

## Customization

### Adding Environment Variables to Generated Makefile (One-Time)

For project-specific customization, edit the generated `Makefile` directly:

```makefile
.PHONY: env
env:
	@echo 'export PROJECT_ROOT="$(CURDIR)"'
	@echo 'export PATH="$(CURDIR)/build/bin:$$PATH"'
	@echo 'export MY_CUSTOM_VAR="custom_value"'  # Add here
```

### Adding Environment Variables to Templates (Permanent)

To add environment variables for all future projects of a language, edit the language template:

**File**: `templates/python/Makefile.template`

Add to the template:
```makefile
# Add Python-specific environment exports
env-python:
	@echo 'export PYTHONPATH="$(CURDIR)/src:$$PYTHONPATH"'
	@echo 'export MY_PYTHON_VAR="value"'
```

Then update `scripts/install.sh` to call `env-python` from the main `env` target.

### Example: Adding Go Environment Setup

**Step 1**: Create `templates/go/Makefile.template`:
```makefile
.PHONY: build-go test-go clean-go lint-go

build-go:
	@echo "Building Go project..."
	go build -o build/bin/myapp ./cmd/myapp

test-go:
	go test ./...

clean-go:
	rm -rf build/

lint-go:
	golangci-lint run
```

**Step 2**: Update `scripts/install.sh` to detect Go projects:
```bash
HAS_GO=false
if [ -f "$MASTER_PROJ/go.mod" ]; then
    HAS_GO=true
fi
```

**Step 3**: Add Go environment exports to `generate_enhanced_makefile()`:
```bash
if $HAS_GO; then
    cat >> "$MASTER_PROJ/Makefile" << 'GO_ENV'
	@echo 'export GOPATH="$(CURDIR)"'
	@echo 'export PATH="$(CURDIR)/bin:$$PATH"'
GO_ENV

    # Append Go template
    if [ -f "$AGENTIZE_ROOT/templates/go/Makefile.template" ]; then
        cat "$AGENTIZE_ROOT/templates/go/Makefile.template" >> "$MASTER_PROJ/Makefile"
    fi
fi
```

### Multi-Language Project Environment Aggregation

For projects with multiple languages, the generated Makefile automatically aggregates environment variables. The order is:

1. Common variables (PROJECT_ROOT, PATH)
2. Python variables (if `HAS_PYTHON=true`)
3. Rust variables (if `HAS_RUST=true`)
4. C/C++ variables (already in PATH)

No manual coordination needed - the `generate_enhanced_makefile()` function handles aggregation.

## Examples

### Python Project Environment Setup

**Using `make env`**:
```bash
cd myproject
eval $(make env)

# Now environment is set:
echo $PROJECT_ROOT  # /Users/dev/myproject
echo $PYTHONPATH    # /Users/dev/myproject/src:...
```

**Using `make env-script`**:
```bash
cd myproject
make env-script     # Generates setup.sh
source setup.sh     # Sets environment

echo $PROJECT_ROOT  # /Users/dev/myproject
```

### Multi-Language Project (Python + C++)

**Environment exports**:
```bash
eval $(make env)

# Aggregated environment:
echo $PROJECT_ROOT  # /Users/dev/myproject
echo $PATH          # /Users/dev/myproject/build/bin:...
echo $PYTHONPATH    # /Users/dev/myproject/src:...
```

**Generated `setup.sh`** (via `make env-script`):
```bash
#!/bin/bash
# Generated by make env-script
PROJECT_ROOT="/Users/dev/myproject"
export PROJECT_ROOT
export PATH="$PROJECT_ROOT/build/bin:$PATH"
export PYTHONPATH="$PROJECT_ROOT/src:$PYTHONPATH"
```

## Technical Notes

### `$(CURDIR)` vs `$(shell pwd)`

**Use `$(CURDIR)`**, not `$(shell pwd)`, for path resolution:

- `$(CURDIR)`: GNU Make built-in, resolves correctly with `make -C`
- `$(shell pwd)`: Shell command, may give incorrect results when using `make -C`

**Example**:
```bash
# From parent directory:
make -C myproject env

# With $(CURDIR): Correctly resolves to /path/to/myproject
# With $(shell pwd): Incorrectly resolves to /path/to/parent
```

### Shell Escaping in Makefiles

Use `$$` to represent a literal `$` in Makefile heredocs:

```makefile
env:
	@echo 'export PATH="$(CURDIR)/bin:$$PATH"'
	#                                 ^^
	#                                 Literal $ in shell
```

Without escaping, Make would try to expand `$PATH` as a Makefile variable (which doesn't exist).

### Symlink Resolution

`$(CURDIR)` resolves symlinks to actual paths. If a project is accessed via symlink (e.g., `~/projects/myapp` â†’ `/Volumes/External/myapp`), `$(CURDIR)` returns the resolved path (`/Volumes/External/myapp`).

This is usually desirable but may surprise users expecting the symlink path. Document this behavior if relevant to your project.

## References

### Internal References
- **Installation script**: `scripts/install.sh` lines 433-546 (`generate_enhanced_makefile()`)
- **Setup template**: `claude/templates/project-setup.sh.template` (reference for env vars)
- **Language templates**: `templates/{python,c,cxx,rust}/Makefile.template`
- **Draft document**: `docs/draft/make-env-target-20251221-094908.md` (design decisions)

### External References
- [GNU Make Environment Documentation](https://www.gnu.org/software/make/manual/html_node/Environment.html) - Official documentation for Make environment variables including `CURDIR`
- [Sharing Variables between GNU Make and Bash](https://honeytreelabs.com/org/shorts/sharing-variables-between-gnu-make-and-the-bash/) - Explains why `eval $(make env)` pattern works
- [Makefile Best Practices - Cloud Posse](https://docs.cloudposse.com/best-practices/developer/makefile/) - Industry best practices for Makefile organization
- [Makefile Tutorial](https://makefiletutorial.com/) - Comprehensive Makefile guide

### Prior Art
- **Docker Machine**: Uses `eval $(docker-machine env <machine>)` pattern for environment setup
- **POSIX shell standards**: Ensure compatibility with bash 3.2+ for macOS support
