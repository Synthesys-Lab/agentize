# Claude Code Hooks for DSA Stack

## Overview

Hooks provide deterministic behavior enforcement at key points in the Claude Code lifecycle. Unlike prompt-based guidance (agents, rules), hooks execute as shell scripts and provide guaranteed behavior.

## Design Philosophy

**Non-blocking by default**: All DSA Stack hooks exit with code 0 (success) even if operations fail. This ensures hooks don't disrupt workflow during the adoption phase. Errors are logged to stderr for debugging.

**Minimal scope**: Each hook does one thing well. Complex logic should live in agents, not hooks.

**Hooks complement agents**: Hooks provide deterministic gates that prompts cannot guarantee. While agents handle intelligent decision-making, hooks enforce programmatic behavior at lifecycle boundaries.

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Hook failure behavior | Non-blocking | Safer adoption; can tighten to blocking later |
| Environment loading | Source `env/dsa-stack.sh` | Consistent with `module load ./env/dsa-stack` |
| File formatting | Optional (skip if tool missing) | Don't block work if formatters not installed |
| JSON formatting | Skipped | Preserve intentional structure in config files |
| Stop hook | Deferred | Add enforcement after adoption phase is stable |

## Available Hooks

### SessionStart Hook

**Script**: `session-init.sh`

**Purpose**: Auto-configure DSA Stack environment on session start.

**Behavior**:
- Sources `env/dsa-stack.sh` (generated by `make env`) for consistent environment
- Falls back to basic PATH addition if env script not found
- Writes to `$CLAUDE_ENV_FILE` for persistence across tool calls

**Exit Code**: Always 0 (non-blocking)

### PostToolUse Hook

**Script**: `post-edit.sh`

**Purpose**: Auto-format files after Edit/Write tool operations.

**Behavior**:
- Requires `jq` for JSON parsing (exits gracefully if not found)
- Python (`.py`): Runs `black --quiet` if available
- C++ (`.cpp`, `.hpp`, `.h`, `.cc`): Runs `clang-format -i` if available
- JSON (`.json`): Skipped (preserve intentional formatting)
- Markdown (`.md`): Skipped (preserve intentional formatting)
- Other extensions: Skipped

**Exit Code**: Always 0 (non-blocking)

### Stop Hook (Future)

**Status**: Deferred

**Purpose**: Enforce completion checks before stopping.

**Planned behavior**: Verify tasks complete, tests run, handoffs created.

## Configuration

Hooks are configured in `.claude/settings.json`:

```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [{
          "type": "command",
          "command": "$CLAUDE_PROJECT_DIR/.claude/hooks/session-init.sh"
        }]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [{
          "type": "command",
          "command": "$CLAUDE_PROJECT_DIR/.claude/hooks/post-edit.sh"
        }]
      }
    ]
  }
}
```

## Writing Custom Hooks

### Input Format

Hooks receive JSON input via stdin:

```json
{
  "session_id": "abc123",
  "hook_event_name": "PostToolUse",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/path/to/file.cpp",
    "content": "..."
  },
  "tool_response": {
    "filePath": "/path/to/file.cpp",
    "success": true
  }
}
```

### Best Practices

1. **Use `jq` for JSON parsing**: `file_path=$(echo "$input" | jq -r '.tool_input.file_path')`
2. **Log to stderr**: `echo "Message" >&2`
3. **Exit 0 for success**: Non-blocking behavior
4. **Exit 2 for blocking errors**: Use sparingly, only when operation must be prevented
5. **Check command availability**: `if command -v tool &> /dev/null; then ...`

### Exit Codes

| Code | Meaning | Effect |
|------|---------|--------|
| 0 | Success | Continue normally |
| 1 | Error (logged) | Continue (depends on event type) |
| 2 | Block | Stop operation, show stderr to user |

## Debugging

Run Claude Code with `--debug` flag to see hook execution details:

```bash
claude --debug
```

Hook output (stderr) appears in the debug logs.

## Verification Procedures

After setting up hooks, verify they work correctly:

### Prerequisites

Ensure environment is generated:
```bash
make env  # Generates env/dsa-stack and env/dsa-stack.sh
```

### Verify SessionStart Hook

1. Start a new Claude Code session in the project
2. Check PATH includes DSA tools:
   ```bash
   which dsa-cc  # Should show path to dsa-cc
   echo $DSA_STACK_ROOT  # Should show project root
   ```
3. If `env/dsa-stack.sh` doesn't exist, you'll see a warning to run `make env`

### Verify PostToolUse Hook

1. Edit a Python file using Claude Code
2. Check the session log for formatting output:
   - Success: No warning messages
   - Missing jq: `Warning: jq not found, hook features limited` in stderr
   - Missing formatter: `Warning: black formatting failed` in stderr
3. Verify Python file is formatted (if black is installed)

## References

> **Note**: Documentation URLs are provided for reference. Claude Code documentation structure may change; search for current documentation if links are broken.

- [Claude Code Hooks Reference](https://docs.anthropic.com/en/docs/claude-code/hooks)
- [Hook Configuration Guide](https://docs.anthropic.com/en/docs/claude-code/hooks#configuration)
